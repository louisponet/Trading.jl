var documenterSearchIndex = {"docs":
[{"location":"strategies/#Strategies","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Trading","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Strategy","category":"page"},{"location":"strategies/#Trading.Strategy","page":"Tutorial","title":"Trading.Strategy","text":"Strategy(name::Symbol, systems::Vector{System}; only_day = false, assets = Asset[])\n\nA strategy embodies a set of Systems that will run periodically, where each of the Systems should have a defined update(s::System, trader, asset_ledgers) function, with asset_ledgers being the AssetLedgers associated with each of the assets that the strategy should be applied on.\n\nnote: Note\n\n\nThe last AssetLedger in asset_ledgers is a \"combined\" ledger which can store data shared between all assets for this strategy.\n\nonly_day: whether this strategy should only run during a trading day\n\n\n\n\n\n","category":"type"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"There are three main parts that need to be implemented for a Strategy to be used:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"a System\nthe Overseer.update function\nthe Overseer.requested_components function","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"This latter one will be used to determine which Indicator systems need to be executed on the data inside each AssetLedger in order to produce the Indicators that are used by the Strategy.","category":"page"},{"location":"strategies/#Strategy-Definition","page":"Tutorial","title":"Strategy Definition","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"As an example we will implement a very simple slow/fast moving average strategy, i.e. SlowFast. The goal is that we can later use it in our Trader in to following way:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"trader = Trader(broker; strategies = [Strategy(:slowfast, [SlowFast()], assets=[Stock(\"stock1\")])])","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We begin by defining the SlowFast System and the components that it requests to be present in AssetLedgers. They will be automatically created as tick data arrives.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"using Trading#hide\nusing Trading.Strategies#hide\nusing Trading.Basic#hide\nusing Trading.Indicators#hide\nusing Trading.Portfolio#hide\nstruct SlowFast <: System end\n\nOverseer.requested_components(::SlowFast) = (SMA{50, Close}, SMA{200, Close})","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We here request the slow and fast sma components of the closing price (SMA{200, Trading.Close}, SMA{50, Trading.Close}).","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We then implement the following update function that will be executed periodically:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"function Overseer.update(s::SlowFast, t::Trader, asset_ledgers)\n    for asset_ledger in asset_ledgers\n\n        asset = asset_ledger.asset\n\n        for e in new_entities(asset_ledger, s)\n            prev_e = prev(e, 1)\n\n            if prev_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n            \n            prev_sma_50 = prev_e[SMA{50, Close}].sma\n            prev_sma_200 = prev_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && prev_sma_50 < prev_sma_200\n                Entity(t, Sale(asset, 1.0))\n            elseif sma_50 < sma_200 && prev_sma_50 > prev_sma_200\n                Entity(t, Purchase(asset, 1.0))\n            end\n\n        end\n    end\nend","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Let's go through this line by line:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"for asset_ledger in asset_ledgers","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We loop through each of the asset ledgers that this strategy was created for (i.e. stock1, stock2).","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"for e in new_entities(asset_ledger, s)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Then, we ask for the new_entities in the AssetLedger that have in this case both the SMA{200, Close} and SMA{50,Close} components. Each of these entities will be touched once and only once.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"prev_e = prev(e, 1)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Since we are looking for crossings between the two moving averages, we ask for the entity of the previous time. If there was none, i.e. e is the very first entity, prev(e, 1) will return nothing and so we don't do anything.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"sma_50  = e[SMA{50, Close}].sma\nsma_200 = e[SMA{200, Close}].sma\n\nprev_sma_50 = prev_e[SMA{50, Close}].sma\nprev_sma_200 = prev_e[SMA{200, Close}].sma","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We retrieve the sma's for both the current and previous entity.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"if sma_50 > sma_200 && prev_sma_50 < prev_sma_200\n    Entity(t, Sale(asset, 1.0))\nelseif sma_50 < sma_200 && prev_sma_50 > prev_sma_200\n    Entity(t, Purchase(asset, 1.0))\nend","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"If the fast sma crosses above the slow sma, we assume the stock is overbought and we sell it by creating an Entity with a  Sale component. Vice versa, If the fast sma crosses below the slow sma, we assume the stock is oversold and we buy it by creating an Entity with a  Purchase component.","category":"page"},{"location":"strategies/#BackTesting","page":"Tutorial","title":"BackTesting","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"The framework is set up to treat backtesting and realtime trading in completely identical ways, and we can therefore backtest our strategy on some historical data.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We first define the broker from which to pull the historical data, in this case we use AlpacaBroker with our key_id and secret. We then use it in the HistoricalBroker which supplies data in the same way of a realtime broker would.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We then set up the strategy for the MSFT and AAPL assets, define our BackTester with our data range and interval dt.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"note: Note\nWhen using daily data (e.g. dt=Day(1)), it is important to specify only_day=false, otherwise nothing will happen since our strategy will only run during trading hours, and no daily bars will have a timestamp inside those hours.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Finally we use start to loop through all the days and execute the strategy, possible trades, and any other behavior as if it is realtime.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nstrategy = Strategy(:slowfast, [SlowFast()], assets=[Stock(\"MSFT\"), Stock(\"AAPL\")])\n\ntrader = BackTester(broker, start = DateTime(\"2015-01-01T00:00:00\"),\n                            stop = DateTime(\"2020-01-01T00:00:00\"),\n                            dt = Day(1),\n                            strategies = [strategy],\n                            cash = 1000,\n                            only_day=false)\nstart(trader)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"To perform further analysis we can transform the trader data into a standard TimeArray as:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"ta = TimeArray(trader)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"by using Plots we can then plot certain columns in the TimeArray, e.g. the portfolio value:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(ta[:portfolio_value])","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We can see that this strategy is not particularly succesful.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"See Slow Fast Strategy for a full runnable version of this strategy.","category":"page"},{"location":"strategies/#References","page":"Tutorial","title":"References","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Trading.relative\nNewEntitiesIterator","category":"page"},{"location":"strategies/#Trading.relative","page":"Tutorial","title":"Trading.relative","text":"relative(ta::TimeArray)\n\nRescales all values in the columns of ta with the first value.\n\n\n\n\n\n","category":"function"},{"location":"strategies/#Trading.NewEntitiesIterator","page":"Tutorial","title":"Trading.NewEntitiesIterator","text":"NewEntitiesIterator\n\nIterates through all the entities in the requested components of a Strategy that were not yet seen.\n\n\n\n\n\n","category":"type"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"EditURL = \"https://github.com/louisponet/Trading.jl/blob/master/docs/src/strategies/slow_fast.jl\"","category":"page"},{"location":"strategies/slow_fast/#slow_fast_id","page":"Slow Fast","title":"Slow Fast Moving Average","text":"","category":"section"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"using Trading\nusing Trading.Strategies\nusing Trading.Basic\nusing Trading.Indicators\nusing Trading.Portfolio\n\nstruct SlowFast <: System end\nOverseer.requested_components(::SlowFast) = (SMA{50, Close}, SMA{200, Close})\n\nfunction Overseer.update(s::SlowFast, t::Trader, asset_ledgers)\n    for asset_ledger in asset_ledgers\n        asset = asset_ledger.asset\n        for e in new_entities(asset_ledger, s)\n            prev_e = prev(e, 1)\n\n            if prev_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n\n            prev_sma_50 = prev_e[SMA{50, Close}].sma\n            prev_sma_200 = prev_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && prev_sma_50 < prev_sma_200\n                Entity(t, Sale(asset, 1.0))\n            elseif sma_50 < sma_200 && prev_sma_50 > prev_sma_200\n                Entity(t, Purchase(asset, 1.0))\n            end\n        end\n    end\nend","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"The Inf values for the quantity of stocks to trade in the Sale and Purchase constructors signifies that we want to buy as many stocks as our cash balance allows for.","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nstrategy = Strategy(:slowfast, [SlowFast()], assets=[Stock(\"MSFT\"), Stock(\"AAPL\")])\n\ntrader = BackTester(broker, start = DateTime(\"2015-01-01T00:00:00\"),\n                            stop = DateTime(\"2020-01-01T00:00:00\"),\n                            dt = Day(1),\n                            strategies = [strategy],\n                            cash = 1000,\n                            only_day=false)\nstart(trader)","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"After having executed the strategy, we can see some quick overview from the output, but by converting it to a TimeArray we can more easily analyse how the strategy performed","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"using Plots\n\nta = TimeArray(trader)\n\nplot(ta[:portfolio_value])","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"We see that in this case the strategy didn't work particularly well. In fact it seems that inverting it, we might get a better result. We can simply redefine our update function as follows:","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"function Overseer.update(s::SlowFast, t::Trader, asset_ledgers)\n    for asset_ledger in asset_ledgers\n        asset = asset_ledger.asset\n        for e in new_entities(asset_ledger, s)\n            prev_e = prev(e, 1)\n\n            if prev_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n\n            prev_sma_50 = prev_e[SMA{50, Close}].sma\n            prev_sma_200 = prev_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && prev_sma_50 < prev_sma_200\n                Entity(t, Purchase(asset, Inf))\n            elseif sma_50 < sma_200 && prev_sma_50 > prev_sma_200\n                Entity(t, Sale(asset, Inf))\n            end\n        end\n    end\nend","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"We have basically swapped the Purchase and Sale components. To execute this updated version we call reset! and start again.","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"reset!(trader)\nstart(trader)","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"and plot the results again, this time taking the relative performances of the portfolio vs the two stocks:","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"ta = Trading.relative(TimeArray(trader))\n\nportfolio_val = ta[:portfolio_value]\naapl_closes = ta[:AAPL_Close]\nmsft_closes = ta[:MSFT_Close]\n\np = plot(merge(portfolio_val, aapl_closes, msft_closes))\nsavefig(\"slow_fast.svg\") # hide\np # hide","category":"page"},{"location":"idea_generation/#Idea-Generation","page":"Idea Generation","title":"Idea Generation","text":"","category":"section"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"Another, perhaps more standard, way to try and come up with new strategies before implementing them as a system is to manipulate data in TimeArrays. Due to the way that the BackTester tries to mimic a true trading situation, it sacrifices a bit of outright speed. This may be fine in most cases, but for true big data it is often faster to work with a TimeArray. Most of this functionality is present in the brilliant TimeSeries and MarketTechnicals packages.","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"We here discuss the slow fast again from this point of view.","category":"page"},{"location":"idea_generation/#Slow-Fast-with-TimeArrays","page":"Idea Generation","title":"Slow Fast with TimeArrays","text":"","category":"section"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"As usual, we define a Broker, and proceed with acquiring the historical data with bars.","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"using Trading#hide\nusing Plots#hide\nusing MarketTechnicals\n\nbroker = AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"])\n\nstart_day = DateTime(\"2015-01-01T00:00:00\")\nstop_day  = DateTime(\"2020-01-01T00:00:00\")\nfull_bars = bars(broker, Stock(\"AAPL\"), start_day, stop_day, timeframe=Day(1))\ndf        = rename(merge(full_bars[:c], full_bars[:o]), [:AAPL_Close, :AAPL_Open])","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"Next, we calculate the two moving averages that we will use in our strategy:","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"sma_ta = merge(sma(df, 20), sma(df, 120))","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"To find crossovers we do:","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"diffs  = rename(sma_ta[:AAPL_Close_sma_20] .- sma_ta[:AAPL_Close_sma_120], :diff)\nsignal = TimeArray(timestamp(diffs), zeros(length(diffs)), [:signal])\ndiffs  = merge(diffs, rename(sign.(diffs), :sign), rename(sign.(lag(diffs,1)), :lagged_sign), signal)\n\ndiffs = map(diffs) do timestamp, vals\n    if vals[2] != vals[3]\n        if vals[1] < 0\n            vals[4] = 1\n        elseif vals[1] > 0\n            vals[4] = -1\n        end\n    end\n    return timestamp, vals\nend\ndiffs[diffs[:signal] .!= 0]","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"Then we fill in our positions and cash balance, and calculate the total position value:","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"signal   = lag(diffs[:signal], 1) # because we buy at open next period\nposition       = rename(cumsum(signal), :position)\nposition_value = rename(df[:AAPL_Close] .* position, :position_value)\ncash           = rename(cumsum(signal .* -1 .* df[:AAPL_Open]), :cash)\ntotal = rename(cash .+ position_value, :total)\ndf = merge(df, position_value, cash, total)\n\nplot([df[:AAPL_Close] df[:total]])","category":"page"},{"location":"idea_generation/","page":"Idea Generation","title":"Idea Generation","text":"We find similar horrible results as in slow fast before.","category":"page"},{"location":"indicators/#Indicators","page":"Indicators","title":"Indicators","text":"","category":"section"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"CurrentModule = Trading","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"The basic Components like Open, Close, High, Low, Volume and their Difference or RelativeDifference components can be used to generate derived Components like:","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"SMA{horizon, base_T}: simple moving average over a window/horizon\nEMA{horizon, base_T}: exponential moving average over a window/horizon\nMovingStdDev{horizon, base_T}: moving standard deviation over a window/horizon\nRSI{horizon, base_T}: moving relative strength index over a window/horizon\nBollinger{horizon, base_T}: Up and Down Bollinger bands","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"These indicators can be requested by Strategy systems for example:","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"struct TestStrat <: System\n\nOverseer.requested_components(::TestStrat) = (SMA{20, Close}, RSI{14, Open})","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"This leads that for any asset that TestStrat should be used on will automatically generate these derived Indicators as the data flows in. It is also used by new_entities to iterate over the new entities in a AssetLedger that hold the requested components for a given Strategy. reset! on the other hand clears all the data for the requested components of a strategy in a AssetLedger. This is useful for example to not use the data of the previous day when calculating moving averages etc.","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"function update(s::TestStrat, trader, asset_ledgers)\n    curt = current_time(trader)\n    if is_market_open(curt)\n        for l in asset_ledgers\n            # This clears the SMA{20, Close} and RSI{14, Open} Components from l\n            reset!(l, s)\n        end\n    end\n    for l in asset_ledgers\n        for e in new_entities(l, s)\n            # do something with e\n\n            # e[SMA{20, Close}] accesses the SMA\n            # e[RSI{14, Open}] accesses the RSI\n        end\n    end\nend","category":"page"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"Each e in the above example will be seen only once. See the Strategies tutorial for more info.","category":"page"},{"location":"indicators/#Reference","page":"Indicators","title":"Reference","text":"","category":"section"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"Trading.SMA\nTrading.MovingStdDev\nTrading.EMA\nTrading.RSI\nTrading.Bollinger\nTrading.Sharpe\nTrading.new_entities\nTrading.reset!(::Trading.AssetLedger, ::Any)","category":"page"},{"location":"indicators/#Trading.SMA","page":"Indicators","title":"Trading.SMA","text":"SMA{horizon, T}\n\nThe simple moving average of a value over a sliding window of horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.MovingStdDev","page":"Indicators","title":"Trading.MovingStdDev","text":"MovingStdDev{horizon, T}\n\nThe moving standard deviation of a value over a sliding window of horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.EMA","page":"Indicators","title":"Trading.EMA","text":"EMA{horizon, T}\n\nThe exponential moving average of a value over a sliding window of horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.RSI","page":"Indicators","title":"Trading.RSI","text":"RSI{horizon, T}\n\nThe relative strength index of a value over timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.Bollinger","page":"Indicators","title":"Trading.Bollinger","text":"Bollinger{horizon, T}\n\nThe up and down Bollinger bands for a value, over a sliding window of horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.Sharpe","page":"Indicators","title":"Trading.Sharpe","text":"Sharpe{horizon, T}\n\nThe sharpe ratio of a value over a timeframe horizon.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.new_entities","page":"Indicators","title":"Trading.new_entities","text":"new_entities(ledger, strategy)\n\nReturns a NewEntitiesIterator which iterates through the entities that have components that are requested by strategy, and were not yet seen. I.e. each entity in those components will be looped over once and only once when iteratively calling new_entities.\n\n\n\n\n\n","category":"function"},{"location":"indicators/#indicator_systems","page":"Indicators","title":"Systems","text":"","category":"section"},{"location":"indicators/","page":"Indicators","title":"Indicators","text":"Trading.SMACalculator\nTrading.MovingStdDevCalculator\nTrading.EMACalculator\nTrading.RSICalculator\nTrading.BollingerCalculator\nTrading.SharpeCalculator","category":"page"},{"location":"indicators/#Trading.SMACalculator","page":"Indicators","title":"Trading.SMACalculator","text":"SMACalculator\n\nCalculates the SMA of data.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.MovingStdDevCalculator","page":"Indicators","title":"Trading.MovingStdDevCalculator","text":"MovingStdDevCalculator\n\nCalculates the MovingStdDev of data.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.EMACalculator","page":"Indicators","title":"Trading.EMACalculator","text":"EMACalculator\n\nCalculates the EMA of data.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.RSICalculator","page":"Indicators","title":"Trading.RSICalculator","text":"RSICalculator\n\nCalculates the RSI of values.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.BollingerCalculator","page":"Indicators","title":"Trading.BollingerCalculator","text":"BollingerCalculator\n\nCalculates the Bollinger bands for data. The width parameter can be tuned, by default it is 2.0.\n\n\n\n\n\n","category":"type"},{"location":"indicators/#Trading.SharpeCalculator","page":"Indicators","title":"Trading.SharpeCalculator","text":"SharpeCalculator\n\nCalculates the bare Sharpe ratio of data.\n\n\n\n\n\n","category":"type"},{"location":"installation/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"CurrentModule=Trading","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"Since the package is registered, you can simply install it using","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"Trading\")","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"After this, it is recommended to set up a Broker. For the moment only Alpaca is supported, and to make the API work, you'll need to generate a set of api keys.","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"Then you can create an AlpacaBroker and you're good to go.","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"See the Tutorial on creating a full strategy, or start with reading about the Trader, the heart of this framework.","category":"page"},{"location":"brokers/#Brokers","page":"Brokers","title":"Brokers","text":"","category":"section"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"CurrentModule=Trading","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"An AbstractBroker signifies the interface between the local Trader and an external party that supplies data, and potentially executes orders and holds the user's portfolio. The current brokers are:","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"AlpacaBroker: the main \"real\" broker\nMockBroker: behaves similarly to a real broker but with random data\nHistoricalBroker: wraps another broker to supply historical data when BackTesting","category":"page"},{"location":"brokers/#Data","page":"Brokers","title":"Data","text":"","category":"section"},{"location":"brokers/#historical_data","page":"Brokers","title":"Historical","text":"","category":"section"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"A slew of historical data can be requested through a broker e.g","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"using Trading#hide\nbroker = AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"])\nbars(broker, Stock(\"AAPL\"), DateTime(\"2023-04-05T00:00:00\"), DateTime(\"2023-04-05T22:00:00\"), timeframe=Minute(1))","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"There are so far three such functions:","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"bars: retrieve historical bar data\ntrades: retrieve historical data on trades\nquotes: retrieve historical data on quotes","category":"page"},{"location":"brokers/#Realtime","page":"Brokers","title":"Realtime","text":"","category":"section"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"The Broker can be queried for the current_price of an asset, and bar data can be streamed in  by calling data_stream, either in realtime from a realtime broker (e.g. AlpacaBroker), or faked realtime when using a HistoricalBroker.","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"For example, internally start_data essentially looks like:","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"data_stream(trader.broker) do stream\n    for (asset, q) in trader.asset_ledgers\n        register!(stream, asset)\n    end\n    while !trader.stop_data\n        bars = receive(stream)\n        # distribute bars to asset ledgers\n    end\nend","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"See register! and receive for further information.","category":"page"},{"location":"brokers/#Orders","page":"Brokers","title":"Orders","text":"","category":"section"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"Orders can be submitted with submit_order and updates to them can be streamed in with trading_stream. Similarly to start_data, start_trading opens an order stream so order updates can be passed along to the Order Component:","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"trading_stream(trader.broker) do stream\n    while !trader.stop_trading\n        order = receive(stream)\n        # update Order component\n    end\nend","category":"page"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"In general, however, these functions should not be used and one should rely on the core systems of the Trader to submit and handle orders through Purchase and Sale Components. See Portfolio for more info.","category":"page"},{"location":"brokers/#References","page":"Brokers","title":"References","text":"","category":"section"},{"location":"brokers/","page":"Brokers","title":"Brokers","text":"Trading.AbstractBroker\nTrading.AlpacaBroker\nTrading.HistoricalBroker\nTrading.MockBroker\nbars\ntrades\nquotes\ncurrent_price\nTrading.DataStream\nTrading.data_stream\nTrading.HTTP.receive(b::Trading.DataStream)\nTrading.register!(b::Trading.DataStream, asset)\nTrading.submit_order\nTrading.TradingStream\nTrading.trading_stream","category":"page"},{"location":"brokers/#Trading.AbstractBroker","page":"Brokers","title":"Trading.AbstractBroker","text":"AbstractBroker\n\nInterface for external brokers.\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.AlpacaBroker","page":"Brokers","title":"Trading.AlpacaBroker","text":"AlpacaBroker(key_id, secret_key)\n\nBroker to communicate with Alpaca. Can be constructed with your key_id and secret_key (see connect-to-alpaca-api).\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.HistoricalBroker","page":"Brokers","title":"Trading.HistoricalBroker","text":"HistoricalBroker(broker)\n\nStores and provides data from historical datasets. Data can be streamed fashion by assigning a Clock to the clock constructor kwarg, which will be used to determine the next bar to stream when calling receive on this broker.\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.MockBroker","page":"Brokers","title":"Trading.MockBroker","text":"MockBroker\n\nMimics all function of a normal broker but with random data.\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.bars","page":"Brokers","title":"Trading.bars","text":"bars(broker, asset, start, stop; timeframe, kwargs...)\n\nRetrieve the bar data for asset from start to stop and with an interval of timeframe. When using AlpacaBroker see the Bar Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\nbars(broker, \"AAPL\",\n     DateTime(\"2022-01-01T00:00:00\"),\n     DateTime(\"2023-01-01T00:00:00\"),\n     timeframe = Minute(1))\n\nThe above will retrieve 2022 bar data \"AAPL\" on a Minute resolution. \n\n\n\n\n\n","category":"function"},{"location":"brokers/#Trading.trades","page":"Brokers","title":"Trading.trades","text":"trades(broker, asset, start, stop)\n\nReturns the trades made for asset between start and stop. When using AlpacaBroker see the Trade Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\ntrades(broker, \"AAPL\", DateTime(\"2022-01-01T14:30:00\"), DateTime(\"2022-01-01T14:31:00\"))\n\n\n\n\n\n","category":"function"},{"location":"brokers/#Trading.quotes","page":"Brokers","title":"Trading.quotes","text":"quotes(broker, asset, start, stop)\n\nReturns the quotes made for asset between start and stop. When using AlpacaBroker see the Quote Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\nquotes(broker, \"AAPL\", DateTime(\"2022-01-01T14:30:00\"), DateTime(\"2022-01-01T14:31:00\"))\n\n\n\n\n\n","category":"function"},{"location":"brokers/#Trading.current_price","page":"Brokers","title":"Trading.current_price","text":"current_price(broker, asset)\ncurrent_price(trader, asset)\n\nReturn the current price of an asset.\n\n\n\n\n\n","category":"function"},{"location":"brokers/#Trading.DataStream","page":"Brokers","title":"Trading.DataStream","text":"DataStream\n\nSupplies a stream of bars from a broker. Can be created by calling data_stream on an AbstractBroker. See receive and register! for more information.\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.data_stream","page":"Brokers","title":"Trading.data_stream","text":"data_stream(f::Function, broker)\n\nOpen a bar stream, calls function f with a DataStream object. Call receive on the DataStream to get new bars streamed in, and register! to register assets for which to receive bar updates for.\n\n\n\n\n\n","category":"function"},{"location":"brokers/#HTTP.WebSockets.receive-Tuple{Trading.DataStream}","page":"Brokers","title":"HTTP.WebSockets.receive","text":"receive(barstream)\n\nBlocking function which will return new bars as soon as they are available.\n\n\n\n\n\n","category":"method"},{"location":"brokers/#Trading.register!-Tuple{Trading.DataStream, Any}","page":"Brokers","title":"Trading.register!","text":"register!(barstream, asset)\n\nRegister a asset to the DataStream so that receive will also return updates with new bars for asset.\n\n\n\n\n\n","category":"method"},{"location":"brokers/#Trading.submit_order","page":"Brokers","title":"Trading.submit_order","text":"submit_order(broker, order::Union{Purchase,Sale})\n\nSubmits the order to a broker for execution.\n\n\n\n\n\n","category":"function"},{"location":"brokers/#Trading.TradingStream","page":"Brokers","title":"Trading.TradingStream","text":"Interface to support executing trades and retrieving account updates. Opened with trading_stream\n\n\n\n\n\n","category":"type"},{"location":"brokers/#Trading.trading_stream","page":"Brokers","title":"Trading.trading_stream","text":"trading_stream(f::Function, broker::AbstractBroker)\n\nCreates an TradingStream to stream order data. Uses the same semantics as a standard HTTP.WebSocket.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\ntrading_stream(broker) do stream\n    order = receive(stream)\nend\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Portfolio","page":"Portfolio","title":"Portfolio","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"CurrentModule=Trading","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"The functionality here can be pulled into the namespace by","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"using Trading.Portfolio","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"A portfolio is represented by a combination of components:","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Cash: the real cash balance of the portfolio, updated as Orders get filled, see current_cash\nPosition: represents a held quantity of an asset. current_position can be used as an easy way to retrieve the position size.\nPurchasePower: can be used to determine whether certain orders can be made, see current_purchasepower. At the start of every cycle this gets equalized with the current Cash, can be used as an estimation of \"future\" cash if certain orders would get executed.\nPortfolioSnapshot: a periodical snapshot of the portfolio","category":"page"},{"location":"portfolio/#Orders","page":"Portfolio","title":"Orders","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"The state of the portfolio can be changed by two types of order:","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Purchase: communicates to the system that a purchase order should be made. Will be executed by the Seller system.\nSale: communicates that a sale order should be made. Will be executed by the Purchaser system.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Each order can have an OrderType which defaults to OrderType.Market, and a TimeInForce which defaults to TimeInForce.GTC (good till canceled). A price can be specified for orders that are not a Market order.","category":"page"},{"location":"portfolio/#Example","page":"Portfolio","title":"Example","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"We first construct a Trader which we start without any strategies.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"broker = AlpacaBroker(\"<key_id>\", \"<secret>\")\n\ntrader = Trader(broker)\n\nstart(trader)","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Now we can interact with it and do some basic trades. First we ask for a Market order on AAPL","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"e = Entity(trader, Purchase(\"AAPL\", 1))","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"After a while e will have a Filled component, signalling that the order was executed succesfully, and","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"current_position(trader, \"AAPL\")","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"will return 1.0.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"We can do the exact same to make a Sale.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"e = Entity(trader, Sale(\"AAPL\", 1))\ncurrent_position(trader, \"AAPL\") # now 0","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"note: Note\nShorting is allowed","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"For different options and order types see OrderType and TimeInForce","category":"page"},{"location":"portfolio/#References","page":"Portfolio","title":"References","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Trading.current_position\nTrading.current_cash\nTrading.current_purchasepower\nTrading.Cash\nTrading.PurchasePower\nTrading.Position\nTrading.Purchase\nTrading.Sale\nTrading.Order\nTrading.Filled\nTrading.PortfolioSnapshot\nTrading.OrderType\nTrading.TimeInForce","category":"page"},{"location":"portfolio/#Trading.current_position","page":"Portfolio","title":"Trading.current_position","text":"current_position(trader, asset::Asset)\n\nReturns the current portfolio position for asset. Returns nothing if asset is not found in the portfolio.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.current_cash","page":"Portfolio","title":"Trading.current_cash","text":"current_cash(trader)\n\nReturns the current cash balance of the trader.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.current_purchasepower","page":"Portfolio","title":"Trading.current_purchasepower","text":"current_purchasepower(trader)\n\nReturns the current PurchasePower.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.Cash","page":"Portfolio","title":"Trading.Cash","text":"Represents the actual cash balance. Currently there is no particular currency tied to this.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.PurchasePower","page":"Portfolio","title":"Trading.PurchasePower","text":"Represents the current purchasing power. This is updated at the start of each update cycle to the current value of the Cash singleton. It can thus be used to determine how many purchases/trades can be made during one cycle.  \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Position","page":"Portfolio","title":"Trading.Position","text":"Represents a position held in an equity represented by asset.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Purchase","page":"Portfolio","title":"Trading.Purchase","text":"Purchase(asset, quantity;\n         type          = OrderType.Market,\n         time_in_force = TimeInForce.GTC,\n         price         = 0.0,\n         trail_percent = 0.0)\n\nThe local representation of a purchase order. This will be turned into an Order by the Purchaser System as soon as it's communicated to the broker. See OrderType and TimeInForce for more information on those kwargs.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Sale","page":"Portfolio","title":"Trading.Sale","text":"Sale(asset, quantity;\n         type          = OrderType.Market,\n         time_in_force = TimeInForce.GTC,\n         price         = 0.0,\n         trail_percent = 0.0)\n\nThe local representation of a sell order. This will be turned into an Order by the Seller System as soon as it's communicated to the broker. See OrderType and TimeInForce for more information on those kwargs.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Order","page":"Portfolio","title":"Trading.Order","text":"Representation of a Purchase or Sale order that has been communicated to the broker. Once the status goes to \"filled\" the filling information will be taken by the Filler System to create a Filled component. \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Filled","page":"Portfolio","title":"Trading.Filled","text":"Represents the filled avg_price and quantity of an Order.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.PortfolioSnapshot","page":"Portfolio","title":"Trading.PortfolioSnapshot","text":"A snapshot of the current Positions and Cash value of the portfolio.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.OrderType","page":"Portfolio","title":"Trading.OrderType","text":"Enum representing the different kinds of orders that can be made.\n\nMarket\nLimit\nStop\nStopLimit\nTrailinStop\n\n\n\n\n\n","category":"module"},{"location":"portfolio/#Trading.TimeInForce","page":"Portfolio","title":"Trading.TimeInForce","text":"Enum representing the lifetime of an order.\n\nDay: till the end of the trading day\nGTC: good till canceled\nOPG: executed on market open\nCLS: executed at market close\nIOC: immediate or canceled, any unfilled part of the order will be canceled\nFOK: executed only when the full quantity can be filled, otherwise canceled.\n\n\n\n\n\n","category":"module"},{"location":"developers/#Developers","page":"Developers","title":"Developers","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"CurrentModule = Trading","category":"page"},{"location":"developers/#Implementing-a-new-[AbstractBroker](@ref)","page":"Developers","title":"Implementing a new AbstractBroker","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"We will use AlpacaBroker as an example for how to implement the AbstractBroker interface.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"Base.@kwdef mutable struct AlpacaBroker <: AbstractBroker\n    key_id::String\n    secret_key::String\n    cache::DataCache = DataCache()\n    rate::Int = 200\n    last::TimeDate = current_time()\n    @atomic nrequests::Int\n\n    function AlpacaBroker(key_id, secret_key, cache, rate, last, nrequests)\n        try\n            header = [\"APCA-API-KEY-ID\" => key_id, \"APCA-API-SECRET-KEY\" => secret_key]\n            testurl = URI(\"https://paper-api.alpaca.markets/v2/clock\")\n            resp = HTTP.get(testurl, header)\n        catch e\n            throw(AuthenticationException(e))\n        end\n        return new(key_id, secret_key, cache, rate, last, nrequests)\n    end\nend","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"key_id and secret_key are used in the constructor for authentication verification, and later on for making api calls. However, these are not assumed to be present and are thus not part of the interface.","category":"page"},{"location":"developers/#.cache-[DataCache](@ref)","page":"Developers","title":".cache DataCache","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"The functions:","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"bars(broker)\nquotes(broker)\ntrades(broker)","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"are defined for an AbstractBroker, but assume that the AbstractBroker has a field .cache which is a DataCache so it is advised for any AbstractBroker to follow the convention that it has a .cache field.","category":"page"},{"location":"developers/#Wrapper-Broker","page":"Developers","title":"Wrapper Broker","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"If you would want to construct a \"wrapper\" broker, i.e. wrapping the broker which supplies the actual API to alter its default behavior (HistoricalBroker is an example of this), you should overload the broker(broker) function to return the \"actual\" broker:","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"broker(b::HistoricalBroker) = b.broker\nbroker(b::AlpacaBroker) = b","category":"page"},{"location":"developers/#data_query","page":"Developers","title":"data_query","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Next up is the data_query(broker, asset, start, stop, args...; section = [\"bars\" or \"quotes\" or\"trades\"], [timeframe=DateTime if section == \"bars\"]) function, which performs the actual api calls to retrieve either bars, quotes or trades from the broker. What to retrieve is communicated through the section kwarg, and in the case of bars it will be called using the timeframe kwarg. This should return a TimeFrame.","category":"page"},{"location":"developers/#Bars","page":"Developers","title":"Bars","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"The bars(broker, msg::Vector) function should be overloaded to be used in DataStream to parse incoming bar updates. It should return a Vector of (asset, (datetime, (bar_open, bar_high, bar_low, bar_close, bar_volume))):","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"function bars(::Union{AlpacaBroker,MockBroker}, msg::AbstractVector)\n    return map(filter(x -> x[:T] == \"b\", msg)) do bar\n        asset = bar[:S]\n        return asset, (parse_time(bar[:t]), (bar[:o], bar[:h], bar[:l], bar[:c], bar[:v]))\n    end\nend","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"The function subscribe_bars(broker, asset, websocket) should be overloaded in order to communicate to a DataStream which assets we want to receive updates for.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"data_stream_url(broker) should point to a url from which we can stream bar update data. authenticate_data(broker) is called just after opening the stream.","category":"page"},{"location":"developers/#Orders","page":"Developers","title":"Orders","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"The first function to overload is submit_order(broker, order::EntityState{Purchase or Sale}) which actually submites the orders. I think the AlpacaBroker one can be used with other Brokers, given that a couple of overloads are defined, but I'm not sure if the structure would always be the same.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"Next up is receive_order(broker, websocket) which is called by the trading_task to listen to Order updates and thus potentially portfolio updates (when filled). It should return an Order.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"To be able to open the TradingStream trading_stream_url(broker) should be overloaded and authenticate_trading(broker, websocket) which also sends the right message to start listening to the updates.","category":"page"},{"location":"developers/#Account-Details","page":"Developers","title":"Account Details","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Upon construction a Trader will fill out the current portfolio by calling account_details(broker) which should return (cash, positions) where positions = [(asset, quantity), (asset, quantity), ...].","category":"page"},{"location":"developers/#References","page":"Developers","title":"References","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"DataCache","category":"page"},{"location":"developers/#Trading.DataCache","page":"Developers","title":"Trading.DataCache","text":"A cache used by Brokers to store previously retrieved historical data.\n\n\n\n\n\n","category":"type"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"EditURL = \"https://github.com/louisponet/Trading.jl/blob/master/docs/src/strategies/cointegration.jl\"","category":"page"},{"location":"strategies/cointegration/#Cointegration","page":"Cointegration","title":"Cointegration","text":"","category":"section"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Here we demonstrate the most basic form of Cointegration/statistical arbitrage by pair trading AAPL and MSFT","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"using Trading\nusing Trading.Strategies\nusing Trading.Basic\nusing Trading.Indicators\nusing Trading.Portfolio\nusing Trading.Time","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"First we define our strategy Systems and the additional components that we need.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"@component struct Spread <: Trading.SingleValIndicator{Float64}\n    v::Float64\nend\n\nstruct SpreadCalculator <: System\n    γ::NTuple{5,Float64} # 1 cointegration ratio per day of the week\nend\n\nOverseer.requested_components(::SpreadCalculator) = (LogVal{Close}, )\n\nstruct PairStrat{horizon} <: System\n    γ::NTuple{5,Float64} # 1 cointegration ratio per day of the week\n    z_thr::Float64 # Threshold of the z_score above or below which we enter positions\nend\nOverseer.requested_components(::PairStrat{horizon}) where {horizon} = (Spread, SMA{horizon, Spread},MovingStdDev{horizon, Spread})\n\n@component struct ZScore{T} <: Trading.SingleValIndicator{Float64}\n    v::T\nend","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Subtyping the SingleValIndicator will allow the automatic calculation of the single moving average and moving standard deviation necessary for our strategy. It is also important to have .v as the value field. If this is undesired you can overload Trading.value for your component type.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Next we specify the update functions. In this more complicated strategy, we need to keep track of the Spread between two assets. To facilitate this notion of shared or combined data, a ledger will be automatically generated with the name of shared assets separated by _, i.e. MSFT_AAPL in our current example. This combined ledger will be the last entry in the asset_ledgers argument.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"function Overseer.update(s::SpreadCalculator, m::Trading.Trader, asset_ledgers)\n\n    @assert length(asset_ledgers) == 3 \"Pairs Strategy only implemented for 2 assets at a time\"\n    combined_ledger = asset_ledgers[end]\n\n    curt = current_time(m)\n\n    # We clear all data from the previous day at market open\n    if Trading.is_market_open(curt)\n        for l in asset_ledgers[1:2]\n            reset!(l, s)\n        end\n    end\n\n    new_bars1 = new_entities(asset_ledgers[1], s)\n    new_bars2 = new_entities(asset_ledgers[2], s)\n\n    assets = map(x->x.asset, asset_ledgers[1:2])\n    @assert length(new_bars1) == length(new_bars2) \"New bars differ for assets $assets\"\n\n    γ = s.γ[dayofweek(curt)]\n    for (b1, b2) in zip(new_bars1, new_bars2)\n        Entity(combined_ledger, Trading.TimeStamp(curt), Spread(b1.v - γ * b2.v))\n    end\n    update(combined_ledger)\nend\n\nfunction Overseer.update(s::PairStrat, m::Trading.Trader, asset_ledgers)\n    curt = current_time(m)\n    if Trading.is_market_open(curt)\n        reset!(asset_ledgers[end], s)\n    end\n\n    !in_day(curt) && return\n\n    cash = m[Trading.PurchasePower][1].cash\n    new_pos = any(x -> x ∉ m[Trading.Order], @entities_in(m, Purchase || Sale))\n\n    asset1 = asset_ledgers[1].asset\n    asset2 = asset_ledgers[2].asset\n\n    γ = s.γ[dayofweek(curt)]\n    z_comp = asset_ledgers[end][ZScore{Spread}]\n\n    for e in new_entities(asset_ledgers[end], s)\n\n        v         = e.v\n        sma       = e.sma\n        σ         = e.σ\n        z_score   = (v - sma) / σ\n        asset_ledgers[end][e] = ZScore{Spread}(z_score)\n        new_pos && continue\n\n\n        curpos1 = current_position(m, asset1)\n        curpos2 = current_position(m, asset2)\n\n        p1 = current_price(m, asset1)\n        p2 = current_price(m, asset2)\n\n        quantity2(n1) = round(Int, n1 * p1 * γ / p2)\n\n        in_bought_leg = curpos1 > 0\n        in_sold_leg = curpos1 < 0\n\n        if z_score < -s.z_thr&& (in_sold_leg || curpos1 == 0)\n            new_pos = true\n            if in_sold_leg\n                q = -2*curpos1\n            else\n                q = cash/p1\n            end\n            Entity(m, Purchase(asset1, round(Int, q)))\n            Entity(m, Sale(asset2, quantity2(q)))\n\n\n        elseif z_score > s.z_thr && (in_bought_leg || curpos1 == 0)\n            new_pos = true\n            if in_bought_leg\n                q = 2*curpos1\n            else\n                q = cash / p1\n            end\n            Entity(m, Purchase(asset2, quantity2(q)))\n            Entity(m, Sale(asset1, round(Int, q)))\n        end\n\n        prev_e = prev(e, 1)\n        prev_e === nothing && continue\n\n        if new_pos || prev_e ∉ z_comp\n            continue\n        end\n\n        going_up = z_score - z_comp[prev_e].v > 0\n        if z_score > 0 && in_bought_leg && !going_up\n            Entity(m, Sale(asset1, curpos1))\n            Entity(m, Purchase(asset2, -curpos2))\n            new_pos = true\n        elseif z_score < 0 && in_sold_leg && going_up\n            Entity(m, Purchase(asset1, -curpos1))\n            Entity(m, Sale(asset2, curpos2))\n            new_pos = true\n        end\n    end\nend","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"As usual we then specify our broker for the backtest. We here show an advanced feature that allows one to specify transaction fees associated with trades. We here define a fee per traded share, but no fixed or variable transaction fees. See HistoricalBroker for more information.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nbroker.variable_transaction_fee = 0.0\nbroker.fee_per_share = 0.005\nbroker.fixed_transaction_fee = 0.0;\nnothing #hide","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Next we specify the daily cointegration parameters that were fit to 2022 data, and run the backtest on Minute data from the first 3 months of 2023.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"γ = (0.83971041721211, 0.7802162996942561, 0.8150936011572303, 0.8665354500999517, 0.8253480013737815)\n\nstratsys = [SpreadCalculator(γ), PairStrat{20}(γ, 2.5)]\nsim_start =TimeDate(\"2023-01-01T00:00:00\")\nsim_stop = TimeDate(\"2023-03-31T23:59:59\")\ntrader = BackTester(broker; strategies=[Strategy(:pair, stratsys, assets=[Stock(\"MSFT\"), Stock(\"AAPL\")])],\n                            start=sim_start,\n                            stop=sim_stop)\n\nstart(trader)","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"We then can analyse our portfolio value. Here we use Trading.only_trading to only show the data during trading days.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"using Plots\nplot(only_trading(TimeArray(trader)[:portfolio_value]))","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Again we see that this strategy does not particularly work.","category":"page"},{"location":"strategies/cointegration/#Invert","page":"Cointegration","title":"Invert","text":"","category":"section"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"The interesting part is that our strategy is not just bad, it's consistently bad. This means that again, we can invert it and theoretically get a consistently good strategy (big grains of salt here). This can be achieved by inserting one line in the above PairStrat: asset1, asset2 = asset2, asset1.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"function Overseer.update(s::PairStrat, m::Trading.Trader, asset_ledgers)\n    curt = current_time(m)\n    if Trading.is_market_open(curt)\n        reset!(asset_ledgers[end], s)\n    end\n\n    !in_day(curt) && return\n\n    cash = m[Trading.PurchasePower][1].cash\n    new_pos = any(x -> x ∉ m[Trading.Order], @entities_in(m, Purchase || Sale))\n\n    asset1 = asset_ledgers[1].asset\n    asset2 = asset_ledgers[2].asset\n\n    γ = s.γ[dayofweek(curt)]\n    z_comp = asset_ledgers[end][ZScore{Spread}]\n\n    for e in new_entities(asset_ledgers[end], s)\n\n        v         = e.v\n        sma       = e.sma\n        σ         = e.σ\n        z_score   = (v - sma) / σ\n        asset_ledgers[end][e] = ZScore{Spread}(z_score)\n        new_pos && continue\n\n        asset1, asset2 = asset2, asset1\n\n        curpos1 = current_position(m, asset1)\n        curpos2 = current_position(m, asset2)\n\n        p1 = current_price(m, asset1)\n        p2 = current_price(m, asset2)\n\n        quantity2(n1) = round(Int, n1 * p1 * γ / p2)\n\n        in_bought_leg = curpos1 > 0\n        in_sold_leg = curpos1 < 0\n\n        if z_score < -s.z_thr&& (in_sold_leg || curpos1 == 0)\n            new_pos = true\n            if in_sold_leg\n                q = -2*curpos1\n            else\n                q = cash/p1\n            end\n            Entity(m, Purchase(asset1, round(Int, q)))\n            Entity(m, Sale(asset2, quantity2(q)))\n\n\n        elseif z_score > s.z_thr && (in_bought_leg || curpos1 == 0)\n            new_pos = true\n            if in_bought_leg\n                q = 2*curpos1\n            else\n                q = cash / p1\n            end\n            Entity(m, Purchase(asset2, quantity2(q)))\n            Entity(m, Sale(asset1, round(Int, q)))\n        end\n\n        prev_e = prev(e, 1)\n        prev_e === nothing && continue\n\n        if new_pos || prev_e ∉ z_comp\n            continue\n        end\n        going_up = z_score - z_comp[prev_e].v > 0\n        if z_score > 0 && in_bought_leg && !going_up\n            Entity(m, Sale(asset1, curpos1))\n            Entity(m, Purchase(asset2, -curpos2))\n            new_pos = true\n        elseif z_score < 0 && in_sold_leg && going_up\n            Entity(m, Purchase(asset1, -curpos1))\n            Entity(m, Sale(asset2, curpos2))\n            new_pos = true\n        end\n    end\nend","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"We reset the trader, and check our results (see Trading.relative):","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"reset!(trader)\nstart(trader)\n\nta = Trading.relative(only_trading(TimeArray(trader)))\nto_plot = merge(ta[:portfolio_value], Trading.relative(rename(bars(broker, Stock(\"MSFT\"), sim_start, sim_stop, timeframe=Minute(1))[:c], :MSFT_Close)),\n                    Trading.relative(rename(bars(broker, Stock(\"AAPL\"), sim_start, sim_stop, timeframe=Minute(1))[:c], :AAPL_Close)))\n\nplot(to_plot)","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Behold, a seemingly succesful strategy.","category":"page"},{"location":"strategies/cointegration/#Performance-analysis","page":"Cointegration","title":"Performance analysis","text":"","category":"section"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"See Performance Analysis","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"using Trading.Analysis\n\nprintln(\"\"\"\nsharpe:           $(sharpe(trader))\ndownside_risk:    $(downside_risk(trader))\nvalue_at_risk:    $(value_at_risk(trader))\nmaximum_drawdown: $(maximum_drawdown(trader))\n\"\"\"\n);\nnothing #hide","category":"page"},{"location":"asset_ledgers/#Ticker-Ledgers","page":"Asset Ledgers","title":"Ticker Ledgers","text":"","category":"section"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"CurrentModule = Trading","category":"page"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Trading.AssetLedger\nTrading.Asset","category":"page"},{"location":"asset_ledgers/#Trading.AssetLedger","page":"Asset Ledgers","title":"Trading.AssetLedger","text":"AssetLedger\n\nA AssetLedger holds the data for a given ticker as it arrives. Currently this is bar data in the form of Open, High, Low, Close and Volume, produced by a DataStream. If certain derived Indicator data is requested, it also holds this as it is produced by the different systems.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.Asset","page":"Asset Ledgers","title":"Trading.Asset","text":"Represents the various asset classes. So far Stock or Crypto, each with a ticker as identification.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Bar-Components","page":"Asset Ledgers","title":"Bar Components","text":"","category":"section"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Bars are represented internally by the following set of Components, basically standard ohlc and volume:","category":"page"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Open\nClose\nHigh\nLow\nVolume","category":"page"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Their differences (i.e. from one period to the next), and logarithms are represented by:","category":"page"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Difference\nRelativeDifference\nLogVal","category":"page"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Each of these, and some derived quantities, can be requested by a Strategy as discussed in Indicators and demonstrated in more detail in the Strategies tutorial.","category":"page"},{"location":"asset_ledgers/#Reference","page":"Asset Ledgers","title":"Reference","text":"","category":"section"},{"location":"asset_ledgers/","page":"Asset Ledgers","title":"Asset Ledgers","text":"Trading.Open\nTrading.High\nTrading.Low\nTrading.Close\nTrading.Volume\nTrading.Difference\nTrading.RelativeDifference\nTrading.LogVal\nTrading.value","category":"page"},{"location":"asset_ledgers/#Trading.Open","page":"Asset Ledgers","title":"Trading.Open","text":"Open\n\nThe opening price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.High","page":"Asset Ledgers","title":"Trading.High","text":"High\n\nThe highest price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.Low","page":"Asset Ledgers","title":"Trading.Low","text":"Low\n\nThe lowest price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.Close","page":"Asset Ledgers","title":"Trading.Close","text":"Close\n\nThe closing price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.Volume","page":"Asset Ledgers","title":"Trading.Volume","text":"Volume\n\nThe traded volume of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.Difference","page":"Asset Ledgers","title":"Trading.Difference","text":"Difference\n\nThe lag 1 difference.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.RelativeDifference","page":"Asset Ledgers","title":"Trading.RelativeDifference","text":"RelativeDifference\n\nThe lag 1 relative difference.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.LogVal","page":"Asset Ledgers","title":"Trading.LogVal","text":"LogVal\n\nThe logarithm of a value.\n\n\n\n\n\n","category":"type"},{"location":"asset_ledgers/#Trading.value","page":"Asset Ledgers","title":"Trading.value","text":"value(b::SingleValIndicator)\n\nReturns the number that is stored in the SingleValIndicator. This is by default the v field.\n\n\n\n\n\n","category":"function"},{"location":"time/#Time","page":"Time","title":"Time","text":"","category":"section"},{"location":"time/","page":"Time","title":"Time","text":"CurrentModule=Trading","category":"page"},{"location":"time/","page":"Time","title":"Time","text":"Time is represented by the standard DateTime from Base.Dates and ZonedDateTime from TimeZones.jl for more precise timing.","category":"page"},{"location":"time/","page":"Time","title":"Time","text":"note: Note\nA standard DateTime will be assumed to be in central Europe / Zurich time\nTrading.jl is at present not aware of holidays or other market altering behavior, i.e. trading days are assumed to always be Monday-Friday; 9:30am - 4pm.","category":"page"},{"location":"time/#Utility-Functions","page":"Time","title":"Utility Functions","text":"","category":"section"},{"location":"time/","page":"Time","title":"Time","text":"These can be pulled into the main namespace by using Trading.Time.","category":"page"},{"location":"time/","page":"Time","title":"Time","text":"current_time\nmarket_open_close\nin_day\nprevious_trading_day\nis_market_open\nis_market_close\nonly_trading","category":"page"},{"location":"time/#Trading.current_time","page":"Time","title":"Trading.current_time","text":"current_time()\ncurrent_time(broker)\ncurrent_time(trader)\n\nReturns the current time either globally, or of an broker or Trader which is essentially the same as the trader's broker.\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.market_open_close","page":"Time","title":"Trading.market_open_close","text":"market_open_close(time, timezone=tz\"EST\")\n\nReturns the open and closing time of the market located in timezone, and converts it to the local timezone, i.e. central european time. It assumes opening at 9:30am and closing at 4pm.\n\nExample\n\njulia> Trading.market_open_close(DateTime(\"2023-04-05\"))\n(DateTime(\"2023-04-05T15:30:00\"), DateTime(\"2023-04-05T22:00:00\"))\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.in_day","page":"Time","title":"Trading.in_day","text":"in_day(time, args...)\n\nReturns true if the time is within the trading hours on a weekday. The args are passed to market_open_close.\n\nExample\n\njulia> Trading.in_day(DateTime(\"2023-02-02T00:00:00\"))\nfalse\n\njulia> Trading.in_day(DateTime(\"2023-02-02T15:00:00\"))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.previous_trading_day","page":"Time","title":"Trading.previous_trading_day","text":"previous_trading_day(time)\n\nReturns the previous trading day, i.e. skipping saturdays and sundays.\n\nExample\n\njulia> Trading.previous_trading_day(DateTime(\"2023-04-06\"))\n2023-04-05T00:00:00\n\njulia> Trading.previous_trading_day(DateTime(\"2023-04-03\"))\n2023-03-30T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.is_market_open","page":"Time","title":"Trading.is_market_open","text":"is_market_open(time, interval=Minute(1))\n\nTests whether a given time is within interval before market open.\n\nExample\n\njulia> Trading.is_market_open(DateTime(\"2023-04-04T15:31:00\"))\nfalse\n\njulia> Trading.is_market_open(DateTime(\"2023-04-04T15:30:00\"))\ntrue\n\njulia> Trading.is_market_open(DateTime(\"2023-04-04T15:29:00\"))\ntrue\n\njulia> Trading.is_market_open(DateTime(\"2023-04-04T15:28:00\"))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.is_market_close","page":"Time","title":"Trading.is_market_close","text":"is_market_close(time, interval=Minute(1))\n\nTests whether a given time is within interval before market close.\n\nExample\n\njulia> Trading.is_market_close(DateTime(\"2023-04-04T22:01:00\"))\nfalse\n\njulia> Trading.is_market_close(DateTime(\"2023-04-04T22:00:00\"))\ntrue\n\njulia> Trading.is_market_close(DateTime(\"2023-04-04T21:59:00\"))\ntrue\n\njulia> Trading.is_market_close(DateTime(\"2023-04-04T21:58:00\"))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"time/#Trading.only_trading","page":"Time","title":"Trading.only_trading","text":"only_trading(ta::TimeArray)\n\nFilters for data in ta during trading sessions. Uses in_day.\n\n\n\n\n\n","category":"function"},{"location":"time/#Clock","page":"Time","title":"Clock","text":"","category":"section"},{"location":"time/","page":"Time","title":"Time","text":"Clock","category":"page"},{"location":"time/#Trading.Clock","page":"Time","title":"Trading.Clock","text":"Clock\n\nRepresents the internal time of a Trader or AbstractBroker. Its time is updated by Timer and returned by current_time if it is called on the Trader or AbstractBroker.  It also stores dt, the timestamp interval when the Clock is updated manually, for example when being used with a HistoricalBroker.\n\n\n\n\n\n","category":"type"},{"location":"#Trading","page":"Home","title":"Trading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Trading","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to Trading.jl, a powerful event-driven algorithmic trading and backtesting package written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides an easy-to-use framework for defining and executing trading strategies based on technical indicators, as well as backtesting these strategies on historical data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds on the ease of use, extensibility, inherent performance and elegance of the ECS (Entity-Component-System) paradigm, implemented through Overseer.jl, and keeps interoperability with the Julia ecosystem by interfacing with TimeSeries.jl.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Highly customizable and extensible by being based on ECS\nBacktesting and Realtime trading treated on completely equal footing\nSeveral built in indicators such as SMA, EMA, MovingStdDev, RSI and Bollinger\nInteraction with brokers such as Alpaca\nHigh performance, with backtesting on 100k data points within seconds","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To define a trading strategy, all you need to do is implement a Julia struct that subtypes System with an update function that defines the trading logic. The update function is called periodically by the framework and has access to tick data for the assets that the strategy was created for, as well as any technical indicators requested by the strategy. The package includes several built-in technical indicators such as simple moving averages, relative strength index, and exponential moving averages. Users can also define their own custom indicators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MyStrategy <: System end\n\nOverseer.requested_components(::MyStrategy) = (Open, Close, SMA{20, Close}, SMA{200, Close})\n\nfunction Overseer.update(s::MyStrategy, trader, asset_ledgers)\n   for ledger in asset_ledgers\n        for e in new_entities(ledger, s)\n            #Trading logic goes here\n        end\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To execute a trading strategy in real-time, users can create a Trader object with the desired strategies, and connect it to a real-time data source through the different broker APIs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"broker = AlpacaBroker(\"<key_id>\", \"<secret>\")\nstrategy = Strategy(:my_strategy, [MyStrategy()], assets=[Stock(\"AAPL\")])\ntrader = Trader(broker, strategies=[strategy])\nstart(trader)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to backtest a trading strategy on historical data, you can use BackTester instead of Trader with the desired data range, interval, and strategies. The BackTester will simulate the behavior of a realtime Trader on the specified data. Afterward, a TimeArray can be created with the data from the trader, and used for performance analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"trader = BackTester(HistoricalBroker(broker),\n                    strategies=[strategy],\n                    start = <start date>,\n                    stop  = <stop date>,\n                    dt = <data timeframe>)\nstart(trader)\nta = TimeArray(trader)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, the slow fast tutorial eventually leads to (Image: )","category":"page"},{"location":"#Future-Roadmap","page":"Home","title":"Future Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Improved performance analysis, statistics\nImplement standard plotting functionality\nTrader loading and saving\nImplement further signals and Indicators\nBacktest comparisons\nSupport for different Brokers","category":"page"},{"location":"#Other-Packages","page":"Home","title":"Other Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TimeSeries\nMarketTechnicals\nTradingLogic\nMarketData","category":"page"},{"location":"trader/#Trader","page":"Trader","title":"Trader","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"CurrentModule=Trading","category":"page"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.Trader\nTrading.BackTester","category":"page"},{"location":"trader/#Trading.Trader","page":"Trader","title":"Trading.Trader","text":"Trader(broker::AbstractBroker; strategies = Strategy[])\n\nThis is the heart of the entire framework. It holds all the data, systems and references to runtime tasks. It can be constructed with an AbstractBroker and potentially a set of Strategies and starting time.\n\nUpon construction with a realtime broker, the Portfolio will be filled out with the account information retrieved through the broker's API.\n\nDefault Systems\n\nThere are a set of default systems that facilitate handling trade orders and other bookkeeping tasks. These are StrategyRunner, Purchaser, Seller, Filler, SnapShotter, Timer and DayCloser.\n\nRuntime and Control\n\nAfter calling start on the Trader, a couple of tasks will start (multithreaded): Aside from this main_task there are two other tasks:\n\nmain_task:    runs the Core Systems in sequence. This includes StrategyRunner which executes the Strategies \ntrading_task: streams in portfolio and order updates\ndata_task:    streams in updates to the registered assets and updates their AssetLedgers\n\nAside from start there are some other functions to control the runtime:\n\nstop_main:     stops the main_task\nstop_trading:  stops the trading_task\nstop_data:     stops the data_tasks\nstop:          combines the previous 3\nstart_main:    starts the main_task\nstart_trading: starts the trading_task\nstart_data:    starts the data_tasks\n\nAbstractLedger interface\n\nTrader is a subtype of the AbstractLedger type defined in Overseer.jl, meaning that it can be extended by adding more Systems and Components to it. This lies at the heart of the extreme extensibility of this framework. You can think of the current implementation as one working example of an algorithmic trader implementation, but it can be tuned and tweaked with all the freedom. \n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.BackTester","page":"Trader","title":"Trading.BackTester","text":"BackTester(broker::HistoricalBroker;\n           dt = Minute(1),\n           start    = current_time() - dt*1000,\n           stop     = current_time(),\n           cash     = 1e6,\n           only_day = true)\n\nThis creates a Trader and adds some additional functionality to perform a backtest. Since behind the scenes it really is just a tweaked Trader, backtesting mimics the true behavior of the algorithm/strategy if it were running in realtime. By using a HistoricalBroker, the main difference is that the datastreams are replaced with historical data, as are the behavior of current_price and current_time.\n\nSee reset! to be able to rerun a BackTester\n\nKeyword arguments\n\ndt: the timestep or granularity of the data. This will also be the tickrate of the main_task of the Trader.\nstart: the starting time of the backtest \nstop: the stopping time of the backtest\ncash: the starting cash\nonly_day: whether the backtest should only be ran during the day. This mainly improves performance.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Performance-Analysis","page":"Trader","title":"Performance Analysis","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.sharpe\nTrading.downside_risk\nTrading.value_at_risk\nTrading.maximum_drawdown","category":"page"},{"location":"trader/#Trading.sharpe","page":"Trader","title":"Trading.sharpe","text":"sharpe(t::Trader, period::Function=day; risk_free = 0.0)\n\nCalculates the Sharpe ratio of a Trader. The Sharpe ratio is a measure of risk-adjusted return, and is defined as the average excess return earned over the risk-free rate per unit of volatility or total risk (i.e. the standard deviation of the returns).\n\nrisk_free: the risk-free rate to use as a baseline for the Sharpe ratio calculation.              The risk-free rate represents the return an investor can earn from a risk-free investment, such as a Treasury bill.              The default value is 0.0, representing a risk-free rate of 0%.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.downside_risk","page":"Trader","title":"Trading.downside_risk","text":"downside_risk(t::Trader, period::Function=day; required_return=0.0)\n\nCalculates the downside risk of a Trader. Downside risk is a measure of the potential loss of an investment, and is defined as the standard deviation of returns below a certain threshold: required_return.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.value_at_risk","page":"Trader","title":"Trading.value_at_risk","text":"value_at_risk(t::Trader, period::Function=day; cutoff = 0.05)\n\nCalculates the value at risk (VaR) of a Trader. Value at risk is a measure of the potential loss of an investment over a certain time horizon, and is defined as the maximum loss expected at a given confidence level.\n\ncutoff: the confidence level at which to calculate value at risk. The confidence level represents           the probability of the maximum loss being less than or equal to the value at risk.           The default value is 0.05, representing a 5% confidence level.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.maximum_drawdown","page":"Trader","title":"Trading.maximum_drawdown","text":"Calculates the maximum drawdown of a Trader object. Maximum drawdown is a measure of the largest loss experienced by an investment over a certain time period, and is defined as the peak-to-trough decline in portfolio value.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Core-Systems","page":"Trader","title":"Core Systems","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.StrategyRunner\nTrading.Purchaser\nTrading.Seller\nTrading.Filler\nTrading.SnapShotter\nTrading.Timer\nTrading.DayCloser","category":"page"},{"location":"trader/#Trading.StrategyRunner","page":"Trader","title":"Trading.StrategyRunner","text":"Runs all the Strategies.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.Purchaser","page":"Trader","title":"Trading.Purchaser","text":"Handles Purchases. Mainly verifies prices and quantities to be purchased.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.Seller","page":"Trader","title":"Trading.Seller","text":"Handles Sales.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.Filler","page":"Trader","title":"Trading.Filler","text":"When the status of an Order changes to \"filled\", the filled quantity and average fill price is  registered in a Filled Component.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.SnapShotter","page":"Trader","title":"Trading.SnapShotter","text":"SnapShotter([interval::Period = Minute(1)])\n\nTakes a PortfolioSnapshot after each interval, storing Positions, Cash, and total value.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.Timer","page":"Trader","title":"Trading.Timer","text":"Updates the Clock of the Trader.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.DayCloser","page":"Trader","title":"Trading.DayCloser","text":"DayCloser([interval::Period = Minute(1)])\n\nCloses the day. Will run during the time interval [market_close - interval, market_close]. Currently it just removes pending trades.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Reference","page":"Trader","title":"Reference","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.start\nTrading.start_data\nTrading.start_main\nTrading.start_trading\nTrading.stop\nTrading.stop_data\nTrading.stop_main\nTrading.stop_trading\nTrading.reset!(::Trader)","category":"page"},{"location":"trader/#Trading.start","page":"Trader","title":"Trading.start","text":"start(trader::Trader; kwargs...)\n\nStarts all the tasks of a Trader or BackTester. The kwargs are passed to each of the start_main, start_trading and start_data functions.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.start_data","page":"Trader","title":"Trading.start_data","text":"start_data(trader; interval = Minute(1))\n\nStarts the trader.data_tasks. It opens a DataStream for each Asset Class, and registers the AssetLedgers to it, in order to receive bar updates.\n\ninterval: signifies the desired interval of bar updates. If a bar for a given asset arrives after more than interval,             bars will be interpolated between the last and new bar so the time interval between adjacent bars is always interval.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.start_main","page":"Trader","title":"Trading.start_main","text":"start_main(trader::Trader; sleep_time = 1, kwargs...)\n\nStarts the trader.main_task. This periodically executes the core systems of the Trader, with at least sleep_time between executions.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.start_trading","page":"Trader","title":"Trading.start_trading","text":"start_trading(trader)\n\nStarts the trading task. This opens a TradingStream to trader.broker that listens to portfolio and order updates .\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.stop","page":"Trader","title":"Trading.stop","text":"stop(trader)\n\nStops all tasks.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.stop_data","page":"Trader","title":"Trading.stop_data","text":"stop_data(trader)\n\nStops trader.data_tasks.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.stop_main","page":"Trader","title":"Trading.stop_main","text":"stop_main(trader)\n\nStops trader.main_task.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.stop_trading","page":"Trader","title":"Trading.stop_trading","text":"stop_trading(trader)\n\nStops trader.trading_task.\n\n\n\n\n\n","category":"function"},{"location":"trader/#Trading.reset!-Tuple{Trader}","page":"Trader","title":"Trading.reset!","text":"reset!(trader)\n\nResets a Trader to the starting point. Usually only used on a BackTester.\n\n\n\n\n\n","category":"method"}]
}
